name: Backend Bootstrap (First Deployment)

# This workflow handles first-time deployment ONLY
# Run this workflow manually to bootstrap the backend infrastructure
on:
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: baynunah-hr-portal-rg
  AZURE_LOCATION: uaenorth
  AZURE_APP_SERVICE_PLAN: hrportal-plan-be
  AZURE_WEBAPP_NAME: baynunah-hr-portal
  PYTHON_VERSION: '3.11'
  CONFIG_VERSION: '1.0.0'

permissions:
  id-token: write
  contents: read

jobs:
  bootstrap:
    runs-on: ubuntu-latest
    
    steps:
      # ========================================
      # STEP 1: PREFLIGHT VALIDATION
      # ========================================
      - name: Validate Azure OIDC secrets
        run: |
          echo "üîç Validating Azure OIDC authentication secrets..."
          
          MISSING_SECRETS=()
          
          if [ -z "${{ secrets.AZURE_CLIENT_ID }}" ]; then
            MISSING_SECRETS+=("AZURE_CLIENT_ID")
          fi
          
          if [ -z "${{ secrets.AZURE_TENANT_ID }}" ]; then
            MISSING_SECRETS+=("AZURE_TENANT_ID")
          fi
          
          if [ -z "${{ secrets.AZURE_SUBSCRIPTION_ID }}" ]; then
            MISSING_SECRETS+=("AZURE_SUBSCRIPTION_ID")
          fi
          
          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "::error::‚ùå Missing required GitHub secrets:"
            for secret in "${MISSING_SECRETS[@]}"; do
              echo "::error::  - $secret"
            done
            echo "::error::"
            echo "::error::These secrets are required for Azure OIDC authentication."
            echo "::error::Please add them to GitHub repository settings:"
            echo "::error::  Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí New repository secret"
            echo "::error::"
            echo "::error::See DEPLOYMENT_FAILURES_ANALYSIS.md for detailed setup instructions."
            echo "::error::Setup guide: https://learn.microsoft.com/azure/developer/github/connect-from-azure"
            exit 1
          fi
          
          echo "‚úÖ All required Azure OIDC secrets are configured"
      
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate required files exist
        working-directory: backend
        run: |
          echo "üîç Validating required files..."
          
          if [ ! -f "startup.sh" ]; then
            echo "‚ùå ERROR: startup.sh not found"
            exit 1
          fi
          
          if [ ! -f "requirements.txt" ]; then
            echo "‚ùå ERROR: requirements.txt not found"
            exit 1
          fi
          
          if [ ! -f "main.py" ]; then
            echo "‚ùå ERROR: main.py not found"
            exit 1
          fi
          
          echo "‚úÖ All required files exist"

      - name: Azure OIDC Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Check backend state
        id: check_exists
        run: |
          echo "üîç Checking backend state..."
          
          # Check if web app already exists
          if az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} 2>/dev/null; then
            STATE=$(az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} \
                      --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                      --query "state" -o tsv 2>/dev/null || echo "Unknown")
            
            echo "‚ö†Ô∏è Web app '${{ env.AZURE_WEBAPP_NAME }}' already exists!"
            echo "Current state: $STATE"
            echo ""
            
            if [ "$STATE" == "Running" ]; then
              echo "‚ùå ERROR: Backend is already running"
              echo "This is a bootstrap workflow for first-time deployment only."
              echo ""
              echo "Options:"
              echo "1. Use 'backend-deploy.yml' for regular deployments"
              echo "2. Use 'backend-repair.yml' to fix configuration"
              echo "3. Use 'backend-cleanup.yml' to delete and start over"
              exit 1
            else
              echo "‚ö†Ô∏è Backend in $STATE state - will attempt to clean up"
              echo "webapp_exists_broken=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚úÖ Backend does not exist - ready for bootstrap"
            echo "webapp_exists_broken=false" >> $GITHUB_OUTPUT
          fi

      # ========================================
      # STEP 2: CREATE INFRASTRUCTURE
      # ========================================
      - name: Create Resource Group (if missing)
        run: |
          echo "üèóÔ∏è Creating resource group if needed..."
          
          if az group show --name ${{ env.AZURE_RESOURCE_GROUP }} 2>/dev/null; then
            echo "‚úÖ Resource group already exists"
          else
            echo "Creating resource group..."
            az group create \
              --name ${{ env.AZURE_RESOURCE_GROUP }} \
              --location ${{ env.AZURE_LOCATION }}
            echo "‚úÖ Resource group created"
          fi

      - name: Create App Service Plan (if missing)
        uses: nick-fields/retry@v2
        with:
          timeout_minutes: 5
          max_attempts: 3
          retry_wait_seconds: 30
          command: |
            echo "üèóÔ∏è Creating App Service Plan if needed..."
            
            if az appservice plan show --name ${{ env.AZURE_APP_SERVICE_PLAN }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} 2>/dev/null; then
              echo "‚úÖ App Service Plan already exists"
            else
              echo "Creating App Service Plan..."
              az appservice plan create \
                --name ${{ env.AZURE_APP_SERVICE_PLAN }} \
                --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                --location ${{ env.AZURE_LOCATION }} \
                --sku B1 \
                --is-linux
              echo "‚úÖ App Service Plan created"
            fi

      - name: Clean up broken Web App (if needed)
        if: steps.check_exists.outputs.webapp_exists_broken == 'true'
        run: |
          echo "üóëÔ∏è Cleaning up broken Web App..."
          
          # Try to delete the broken web app
          if az webapp delete \
               --name ${{ env.AZURE_WEBAPP_NAME }} \
               --resource-group ${{ env.AZURE_RESOURCE_GROUP }}; then
            echo "‚úÖ Broken Web App deleted"
            
            # Wait for deletion to complete
            echo "‚è≥ Waiting for deletion to propagate..."
            sleep 60
            
            # Verify deletion
            if az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} \
                 --resource-group ${{ env.AZURE_RESOURCE_GROUP }} 2>/dev/null; then
              echo "‚ö†Ô∏è Web App still exists, waiting longer..."
              sleep 60
            fi
          else
            echo "‚ö†Ô∏è Could not delete Web App, will try to create anyway"
          fi

      - name: Create Web App
        uses: nick-fields/retry@v2
        with:
          timeout_minutes: 10
          max_attempts: 3
          retry_wait_seconds: 60
          command: |
            echo "üèóÔ∏è Creating Web App..."
            
            # Edge case: Check if name is available
            AVAILABILITY=$(az webapp list --query "[?name=='${{ env.AZURE_WEBAPP_NAME }}'].name" -o tsv)
            if [ -n "$AVAILABILITY" ]; then
              echo "‚ö†Ô∏è Web App name already in use, checking ownership..."
              
              # Check if it's in our resource group
              OUR_APP=$(az webapp list --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                          --query "[?name=='${{ env.AZURE_WEBAPP_NAME }}'].name" -o tsv)
              
              if [ -z "$OUR_APP" ]; then
                echo "‚ùå ERROR: Web App name taken by another resource group"
                echo "Choose a different name or contact admin"
                exit 1
              fi
            fi
            
            # Try to create web app
            if az webapp create \
                --name ${{ env.AZURE_WEBAPP_NAME }} \
                --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                --plan ${{ env.AZURE_APP_SERVICE_PLAN }} \
                --runtime "PYTHON:${{ env.PYTHON_VERSION }}"; then
              echo "‚úÖ Web App created"
            else
              echo "‚ùå Failed to create Web App"
              echo ""
              echo "This could be because:"
              echo "1. Web App name already in use"
              echo "2. Previous deletion not yet complete"
              echo "3. Insufficient permissions"
              echo "4. Quota limits reached"
              echo ""
              echo "Troubleshooting:"
              echo "‚Ä¢ Wait a few minutes and try again"
              echo "‚Ä¢ Or run 'backend-cleanup.yml' workflow first"
              echo "‚Ä¢ Or choose a different Web App name"
              exit 1
            fi

      # ========================================
      # STEP 3: GENERATE AND PERSIST SECRETS
      # ========================================
      - name: Generate HR_API_KEY (if missing)
        id: generate_secrets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîê Checking if HR_API_KEY exists in GitHub secrets..."
          
          # Check if secret already exists in GitHub
          if gh secret list | grep -q "HR_API_KEY"; then
            echo "‚úÖ HR_API_KEY already exists in GitHub secrets"
            # We'll retrieve it from Azure in the next step
          else
            echo "Generating new HR_API_KEY..."
            HR_API_KEY=$(openssl rand -hex 32)
            echo "hr_api_key=$HR_API_KEY" >> $GITHUB_OUTPUT
            
            # Store in GitHub secrets
            echo "Storing HR_API_KEY in GitHub secrets..."
            echo "$HR_API_KEY" | gh secret set HR_API_KEY --repo ${{ github.repository }}
            echo "‚úÖ HR_API_KEY stored in GitHub secrets"
          fi

      - name: Get or set HR_API_KEY in Azure
        id: sync_hr_key
        run: |
          echo "üîê Syncing HR_API_KEY to Azure..."
          
          # Try to get existing key from Azure
          EXISTING_KEY=$(az webapp config appsettings list \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query "[?name=='HR_API_KEY'].value" -o tsv 2>/dev/null || echo "")
          
          if [ -n "$EXISTING_KEY" ]; then
            echo "‚úÖ HR_API_KEY already exists in Azure"
          elif [ -n "${{ steps.generate_secrets.outputs.hr_api_key }}" ]; then
            echo "Setting new HR_API_KEY in Azure..."
            az webapp config appsettings set \
              --name ${{ env.AZURE_WEBAPP_NAME }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --settings HR_API_KEY="${{ steps.generate_secrets.outputs.hr_api_key }}"
            echo "‚úÖ HR_API_KEY set in Azure"
          else
            echo "‚ùå ERROR: No HR_API_KEY available"
            exit 1
          fi

      - name: Get publish profile
        id: publish_profile
        run: |
          echo "üì• Getting publish profile..."
          
          PUBLISH_PROFILE=$(az webapp deployment list-publishing-profiles \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --xml)
          
          # Store in GitHub secrets
          echo "$PUBLISH_PROFILE" | gh secret set AZURE_BACKEND_PUBLISH_PROFILE --repo ${{ github.repository }}
          
          echo "‚úÖ Publish profile stored in GitHub secrets"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ========================================
      # STEP 4: CONFIGURE WEB APP
      # ========================================
      - name: Configure Web App settings
        run: |
          echo "‚öôÔ∏è Configuring Web App settings..."
          
          # Get frontend URL (if available)
          FRONTEND_URL="${{ secrets.FRONTEND_URL }}"
          if [ -z "$FRONTEND_URL" ]; then
            FRONTEND_URL="https://hrportal-frontend.azurewebsites.net"
            echo "‚ö†Ô∏è FRONTEND_URL not set, using default: $FRONTEND_URL"
          fi
          
          # Configure app settings
          az webapp config appsettings set \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --settings \
              DEBUG="False" \
              CORS_ORIGINS="$FRONTEND_URL,https://*.azurestaticapps.net" \
              DATABASE_URL="sqlite:///./hr_portal.db" \
              CONFIG_VERSION="${{ env.CONFIG_VERSION }}"
          
          # Set startup command
          az webapp config set \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --startup-file "startup.sh"
          
          # Configure SCM build
          az webapp config appsettings set \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --settings \
              SCM_DO_BUILD_DURING_DEPLOYMENT="true" \
              ENABLE_ORYX_BUILD="true"
          
          # Enable HTTPS only
          az webapp update \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --https-only true
          
          echo "‚úÖ Web App configured"

      - name: Configure CORS
        run: |
          echo "üåê Configuring CORS..."
          
          FRONTEND_URL="${{ secrets.FRONTEND_URL }}"
          if [ -z "$FRONTEND_URL" ]; then
            FRONTEND_URL="https://hrportal-frontend.azurewebsites.net"
          fi
          
          az webapp cors add \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --allowed-origins "$FRONTEND_URL" "https://*.azurestaticapps.net"
          
          echo "‚úÖ CORS configured"

      # ========================================
      # STEP 5: DEPLOY BACKEND CODE
      # ========================================
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: backend/requirements.txt

      - name: Install dependencies
        working-directory: backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Verify app runs
        working-directory: backend
        run: python -c "from main import app; print('‚úÖ App imports successfully')"

      - name: Create deployment package
        run: |
          cd backend
          zip -r ../deploy.zip . -x "*.pyc" -x "__pycache__/*" -x ".pytest_cache/*" -x "*.db" -x "tests/*"
          cd ..
          ls -lh deploy.zip

      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_BACKEND_PUBLISH_PROFILE }}
          package: deploy.zip

      # ========================================
      # STEP 6: VERIFY HEALTH
      # ========================================
      - name: Wait for deployment to complete
        run: |
          echo "‚è≥ Waiting for deployment to stabilize..."
          # Azure App Service needs time to:
          # - Extract and build the deployment package
          # - Run pip install for dependencies
          # - Execute startup.sh
          # - Start Gunicorn with Uvicorn workers
          sleep 60

      - name: Health check with retries
        uses: nick-fields/retry@v2
        with:
          timeout_minutes: 10
          max_attempts: 10
          retry_wait_seconds: 15
          command: |
            echo "üè• Running health check..."
            
            WEBAPP_URL="https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
            
            if curl -sf "$WEBAPP_URL/health" -o /tmp/health_response.json; then
              echo "‚úÖ Health check passed"
              cat /tmp/health_response.json
            else
              echo "‚ùå Health check failed"
              echo "Checking application logs..."
              az webapp log tail --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --only-show-errors || true
              exit 1
            fi

      # ========================================
      # STEP 7: LOCK CONFIGURATION
      # ========================================
      - name: Lock configuration version
        run: |
          echo "üîí Locking configuration version..."
          
          az webapp config appsettings set \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --settings \
              CONFIG_VERSION="${{ env.CONFIG_VERSION }}" \
              BOOTSTRAP_COMPLETED="true" \
              BOOTSTRAP_DATE="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          
          echo "‚úÖ Configuration locked with version ${{ env.CONFIG_VERSION }}"

      - name: Bootstrap summary
        run: |
          echo ""
          echo "=========================================="
          echo "‚úÖ BOOTSTRAP COMPLETED SUCCESSFULLY"
          echo "=========================================="
          echo ""
          echo "Backend URL: https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
          echo "Health endpoint: https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/health"
          echo "API docs: https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/docs"
          echo ""
          echo "Next steps:"
          echo "1. Test the backend endpoints"
          echo "2. Use 'backend-deploy.yml' for future deployments"
          echo "3. Use 'backend-repair.yml' for autonomous repairs"
          echo ""
